## Java内存模型与线程

### 处理器与内存的速度矛盾

　　计算机的绝大多数运算任务无法仅靠寄存器来完成，需要处理器和内存进行交互，如读取运算数据、存储运算结果等。
但由于计算机的存储设备与处理器的运算速度有几个数量级的差距，为了能更充分地利用计算机处理器的效能，我们必须找到一种方式来解决两者之间的速度矛盾 —— 高速缓存。
  
　　高速缓存的读写速度尽可能接近处理器的运算速度，由它来作为内存和处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。
  
  #### 缓存一致性问题
  
　　基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性。
在多处理器系统中，每个处理器都有自己的高速内存，而它们又共享同一主内存。
当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。 

　　为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。
  
　　内存模型，可以理解为特定的操作协议下，对特定内存或高速缓存进行读写访问的过程抽象。  
  
　　不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且这里介绍的内存访问操作和硬件的缓存访问操作具有很高的可比性。  
　　除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后进行乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。  
　　因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序优化。
  
  
### Java内存模型

  主要目标：定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。
  
  所说的变量包括：实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数(线程私有，不存在竞争问题)。
  
  #### 主内存和工作内存
  
  Java内存模型规定，所有的变量都存储在主内存(JVM主内存)。每条线程各自有自己的工作内存，且工作前后都要把值再同步回主内存，线程间变量值的传递需要通过主内存来完成。
    
  ![线程、主内存、工作内存三者的交互关系](https://mazhuang.org/favicon.jpg)

  ##### 注意：
  
　　这里所讲的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等不适同一个层次的内存划分，这两者基本上是没有关系的。　　
   
　　如果一定要勉强对应上的话，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分(除了实例数据部分，Java堆还保存了对象其他信息如Mark Word(存储对象哈希码、GC标志、GC年龄、同步锁等信息)、Klass Point(指向存储类型元数据的指针)及一些用于字节对齐补白的填充数据)，而工作内存则对应于虚拟机栈中的部分区域。  
　　从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获得更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速内存中，因为程序运行时主要访问读写的是工作内存。
  
  #### 内存间交互操作
  
  一个变量是如何在主内存和工作内存之间交互的呢？具体怎么样去实现？
  
  Java内存模型中定义了8种原子性操作，用来实现主内存和工作内存的交互。
  
  - **lock**(锁定)：作用于**主内存**的变量，将变量标识为一条线程独占的状态。
  - **unlock**(解锁)：作用于**主内存**的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 
  
  - **read**(读取)：作用于**主内存**的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
  - **load**(载入)：作用于**工作内存**的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中。  
  
  - **use**(使用)：作用于**工作内存**的变量，把工作内存中的一个变量的值传递到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行此操作。
  - **assign**(赋值)：作用于**工作内存**的变量，把一个从执行引擎接受到的值赋给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
  
  - **store**(存储)：作用于**工作内存**的变量，把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
  - **write**(写入)：作用于**主内存**的变量，把store操作从工作内存中得到的变量的值放入主内存变量中。
  
  #### 8种基本操作必须满足以下规则：
    
   1. read & load, store & write 必须成对出现，且必须按顺序执行，但不要求连续执行。
   
   2. 变量改变后必须从工作内存同步回主内存，未改变不允许同步。  
      不允许一个线程丢弃它最近的assign操作；  
      不允许一个线程无原因地(无assign操作)把数据从线程的工作内存同步回主内存。
      
   3. 新变量只能在内存中诞生，换句话说，就是对一个变量实施use、store操作之前，必须先执行assign和load操作。
   
   4. 一个变量在同一时刻只允许一条线程对其进行lock操作。
   
   5. 如果对一个变量进行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用该变量前，需要重新执行load或assign操作初始化变量的值。
   
   6. 如果一个变量实现没有被lock操作锁定，那就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁住的变量。
   
   7. 对一个变量执行unlock操作之前，必须先把此变量同步回主内存(stroe、write)
      
