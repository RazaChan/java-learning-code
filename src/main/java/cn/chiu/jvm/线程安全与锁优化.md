
### 线程安全

  > 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的
    协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。

  这个定义比较严谨，它要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段，领调用者无须关心多线程的问题，
  更无须自己采取任何措施来保证多线程的正确调用。


### Java语言中的线程安全

  #### Java语言中各种操作共享的数据大致分为5类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。

  1. 不可变

     Java中如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。
     如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行。

  2. 绝对线程安全

  3. 相对线程安全

     相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作时线程安全的，我们在调用的时候不需要做额外的保障
     措施，但是对一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

     在Java中大部分的线程安全类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等。

  4. 线程兼容

     线程兼容是指对象本身不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。
     我们平常所说的一个类不是线程安全的，绝大多数时候指的就是这种情况。

     在Java中大部分的类都是属于线程兼容的。

  5. 线程对立

     线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种
     排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。

     一个线程对立的例子是Thread类的suspend()和resume()方法。如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，
     如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的。
     也正是这个原因，两个方法已经被jdk声明废弃了。

     常见的线程对立操作还有System.serIn()、System.setOut()、System.runFinalizersOnExit()等。


### 线程安全的实现方法

  ###### 本节通过虚拟机如何实现同步和锁来实现安全运作来了解线程安全的实现

  1. 互斥同步(阻塞同步)

     互斥同步是一种常见的并发正确性保障手段。

     同步: 多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。
     互斥: 实现同步目的的一种手段，主要实现方式有临界区、互斥量、信号量

     Java中最基本的同步互斥手段就是 synchronized关键字。 synchronized关键字经过编译后，会在同步块的前后分别形成 monitorenter 和 monitorexit 两个字节码命令，
     这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果未明确指定，
     那么就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。

     Java还可以使用java.util.concurrent包中的重入锁(ReentrantLock)来实现同步。

     synchronized和ReentrantLock对比:
     - 两者都具备一样的线程重入特性，知识代码上有点区别:
         - 一个表现为API层面的互斥锁(lock()和unlock()方法配合try/finally语句块来完成)
         - 一个表现为原生语法层面的互斥锁

     ReentrantLock高级功能：等待可中断、可实现公平锁、锁可以绑定多个条件。

         - 等待可中断: 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待。可中断特性对处理执行时间非常长的同步块很有帮助。
         - 可实现公平锁: 保证锁被释放时，严格按照申请锁的时间顺序来依次获得锁。(synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数来要求使用公平锁)
         - 锁绑定多个条件: 一个ReentrantLock对象可以同时绑定多个Condition对象


  2. 非阻塞同步

     互斥同步最主要的问题是 进行线程阻塞和唤醒所带来的性能问题。

     从处理方式上说，互斥同步属于一种悲观的并发策略，不论共享数是否会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。

     --->> 基于冲突检测的乐观并发策略:

        先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据由争用，产生了冲突，那就再采取其他补偿措施(常见措施：不断重试直到成功)

     #### CAS指令和ABA问题

     CAS指令: CAS指令有3个操作数，分别是内存位置V、旧的预期值A和新值B。指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它旧不执行更新，但是无论是否更新了V值，
     都会返回V的旧值，上述处理过程为一个原子操作。

     ABA问题: 我们不能保证一个变量在初次读取到准备赋值期间是否有A改成了B后来又被改回A，如此情况CAS操作会误认为它没有被改变过。


    3. 无同步方案

       如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施来保证正确性，因此有一些代码天生就是线程安全的。
